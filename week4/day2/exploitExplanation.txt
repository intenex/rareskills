The exploit here involves noticing that PRICE_PER_TOKEN is 10 ** 18 (1 ether), so multiplying (2 ** 256 - 1) / 10 ** 18 + 1 will yield a number that will overflow the uint256 exactly by 1 when multiplied by PRICE_PER_TOKEN for the required msg.value.

Thus, passing in exactly 115792089237316195423570985008687907853269984665640564039458, which when multiplied by 10 ** 18 is

115792089237316195423570985008687907853269984665640564039458000000000000000000, will, when subtracted against the maximum uint256 value + 1 (effectively equal to 0)

115792089237316195423570985008687907853269984665640564039457584007913129639936 (this is equal to 0, aka 2 ** 256), equal precisely

415992086870360064, which is equivalent to 0.415992086870360064 * 10 ** 18, or that much ether.

So pass that as the msg.value, and now the balance of tokens owned by the user is 115792089237316195423570985008687907853269984665640564039458, so you can call the sell function with 1 passed in and receive 1 ether back, meaning the contract now has only

0.415992086870360064 ether, or less than 1, therefore passing the exploit