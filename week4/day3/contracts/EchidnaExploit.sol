pragma solidity ^0.8.17;

import {Dex, SwappableToken} from "./Dex.sol";

// We are using an external testing methodology
contract EchidnaExploit {
    Dex dexContract;
    SwappableToken tokenContract1;
    SwappableToken tokenContract2;

    // setup
    constructor() {
        dexContract = new Dex();
        tokenContract1 = new SwappableToken(
            address(dexContract),
            "Token1",
            "TOK1",
            10 ether
        );
        tokenContract2 = new SwappableToken(
            address(dexContract),
            "Token2",
            "TOK2",
            10 ether
        );
        dexContract.setTokens(address(tokenContract1), address(tokenContract2));
        dexContract.renounceOwnership();
    }

    // function testBalanceSetup() public view {
    //     assert(
    //         dexContract.balanceOf(address(tokenContract1), address(this)) ==
    //             10 ether
    //     );
    //     assert(
    //         dexContract.balanceOf(address(tokenContract2), address(this)) ==
    //             10 ether
    //     );
    //     assert(
    //         dexContract.balanceOf(
    //             address(tokenContract1),
    //             address(dexContract)
    //         ) == 100 ether
    //     );
    //     assert(
    //         dexContract.balanceOf(
    //             address(tokenContract2),
    //             address(dexContract)
    //         ) == 100 ether
    //     );
    // }

    // The bool _fromContract ensures that we correctly bound the inputs to .swap with only the two correct addresses
    function testSwap(uint256 _stakedAmount, bool _fromContract) public {
        address fromContract = _fromContract
            ? address(tokenContract1)
            : address(tokenContract2);
        address toContract = _fromContract
            ? address(tokenContract2)
            : address(tokenContract1);
        // This bounds the stakedAmount to be between 0 and 10 ether so we know it's a generally valid amount to swap. Theoretically bigger values should be fine later but works well enough.
        uint256 stakedAmount = _stakedAmount % 10 ether;
        dexContract.approve(address(dexContract), stakedAmount);
        dexContract.swap(fromContract, toContract, stakedAmount);
        // theoretically should never fall below 90 ether so testing at 90 ether is sufficient to poc the basic failure case; 80 ether gives many transactions to follow step by step down to 0
        assert(
            dexContract.balanceOf(fromContract, address(dexContract)) >=
                80 ether
        );
        assert(
            dexContract.balanceOf(toContract, address(dexContract)) >= 80 ether
        );
    }
}
